[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

``` 
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
```

```
## 哈哈，第一次提交，想了一个复杂的方式来标记层的开始，不太好。
# class Solution:
#     def levelOrder(self, root: TreeNode) -> List[List[int]]:
#         # 出队访问
#         if root==None: return []
#         from collections import deque
#         d = deque()
#         d.append(None)
#         if root: d.append(root)
#         res = []
#         lay_no_next_total = 0
#         lay_no_this_total = 1
#         lay_no_been_visited = 0

#         while(d):
#             out = d.popleft()
#             if out == None:
#                 # if d==None: break  # d空了，这么写是错的！！！！！！！！！！！
#                 if len(d)==0: break# d内已经没有节点了 
#                 layer = []
#                 d.append(None) # 即将是新的一层，那么新的一层的子节点之前也为None
#                 continue

#             if out.left: # 先统计下一层的节点数目
#                 d.append(out.left)
#                 lay_no_next_total += 1
#             if out.right: 
#                 d.append(out.right)
#                 lay_no_next_total += 1
            
#             layer.append(out.val) # 统计当前层已经访问过的节点数目
#             lay_no_been_visited += 1
#             if lay_no_been_visited==lay_no_this_total:
#                 res.append(layer)
#                 lay_no_this_total = lay_no_next_total
#                 lay_no_next_total = 0
#                 lay_no_been_visited = 0
#         return res

# 随想录：
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        from collections import deque
        dq = deque()
        if root: dq.append(root)

        while(dq):
            len_q = len(dq)
            layer = []
            for i in range(len_q):
                out = dq.popleft()
                layer.append(out.val)
                if out.left: dq.append(out.left)
                if out.right: dq.append(out.right)
            res.append(layer)
        return res
```


[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

``` 
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        res = []
        from collections import deque
        dq = deque()
        if root: dq.append(root)

        while(dq):
            len_q = len(dq)
            layer = []
            for i in range(len_q):
                out = dq.popleft()
                layer.append(out.val)
                if out.left: dq.append(out.left)
                if out.right: dq.append(out.right)
            res.append(layer)
        res.reverse()
        return res
```


[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```
# # 从基本代码中返回，每一层的最后一个节点。
# class Solution:
#     def rightSideView(self, root: TreeNode) -> List[int]:
#         res = []
#         from collections import deque
#         dq = deque()
#         if root: dq.append(root)

#         while(dq):
#             len_q = len(dq)
#             layer = []
#             for i in range(len_q):
#                 out = dq.popleft()
#                 layer.append(out.val)
#                 if out.left: dq.append(out.left)
#                 if out.right: dq.append(out.right)
#             res.append(layer)
        
#         return [layer[-1] for layer in res]

# 或者, 直接将dq[-1] 加入 res
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        res = []
        from collections import deque
        dq = deque()
        if root: dq.append(root)

        while(dq):
            len_q = len(dq)
            res.append(dq[-1].val)
            for i in range(len_q):
                out = dq.popleft()
                if out.left: dq.append(out.left)
                if out.right: dq.append(out.right)
        return res
        
```


[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

``` 
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        res = []
        from collections import deque
        dq = deque()

        if root: dq.append(root)
        while(dq):
            layer = []
            for i in range(len(dq)):
                tree_node = dq.popleft()
                layer.append(tree_node.val)
                if tree_node.left: dq.append(tree_node.left)
                if tree_node.right: dq.append(tree_node.right)
            res.append(sum(layer)/len(layer))
        return res
```



[429.N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

``` 
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        res = []
        from collections import deque
        dq = deque()
        if root: dq.append(root)

        while(dq):
            layer = []
            for i in range(len(dq)):
                out = dq.popleft()
                layer.append(out.val)
                if out.children:
                    for child in out.children: dq.append(child)
            res.append(layer)
        return res    
```



[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

``` 
class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        from collections import deque
        dq = deque()
        if root: dq.append(root)

        while(dq):
            len_q = len(dq)
            layer = []
            for i in range(len_q):
                out = dq.popleft()
                layer.append(out.val)
                if out.left: dq.append(out.left)
                if out.right: dq.append(out.right)
            res.append(max(layer))
        return res
```


[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

``` 

class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        res = []
        from collections import deque
        dq = deque()
        if root: dq.append(root)

        while(dq):
            len_q = len(dq)    
            for i in range(len_q-1):#
                out = dq.popleft()
                out.next = dq[0]
                if out.left: dq.append(out.left)
                if out.right: dq.append(out.right)
            last_node = dq.popleft() # 上一层最后一个node出队
            if last_node.left: dq.append(last_node.left)
            if last_node.right: dq.append(last_node.right)

        return root
```


[117.填充每个节点的下一个右侧节点指针II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

``` 

```


[]()

``` 
```


[]()

``` 
```


[]()

``` 
```


[]()

``` 
```


[]()

``` 
```


[]()

``` 
```


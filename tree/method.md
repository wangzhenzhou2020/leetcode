访问节点：弹出节点，

处理节点：处理节点的值。


空节点也可以入栈或者入队。

涉及两棵树的，一般**递归的输入是两棵树**：

101对称二叉树，100.相同的树，572.另一个树的子树

迭代的话，也是同时处理两个节点。

什么时候递归参数是两个：两颗独立的树。没有必要把左右子树作为两个参数传入递归函数，啰嗦复杂。因为可以通过一个父节点访问到两个子树，那么使用父节点作为参数比较合适。

关于递归的参数, 有时候可以用返回值来记录变化的量，也可以用全局变量来记录变化的量。但最好能用全局变量来记录。递归的参数尽量是必要的，和当前的递归非常相关的参数，这样更简单。

如：513. 找树左下角的值

递归函数的返回值：
如果满足解题条件就要退出递归，比如搜索路径，那么就一定要返回值。用底层的返回值来避免高层其他无用的递归。
112.路径总和

树递归的终止条件不一定是空节点。 257.二叉树的所有路径

递归也可以*配合全局变量*。如： 104.二叉树的最大深度   或者 回溯。


递归的空间复杂度 = *每次递归的空间复杂度 * 递归深度*


虽然理论上所有的递归都可以用迭代来实现，但是有的场景难度可能比较大。

例如：都知道回溯法其实就是递归，但是很少人用迭代的方式去实现回溯算法！

因为对于回溯算法已经是非常复杂的递归了，如果在用迭代的话，就是自己给自己找麻烦，效率也并不一定高。

中序和后序一般是O(logn)，为了保护根节点的现场。
而先序递归也是O(logn)，因为要保护根节点右孩子的现场。

二叉树的最后一层的节点数是O(n)的。即 2^( 深度 =  log2(n) ) = O(n)










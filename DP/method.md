动态规划是 有状态的，贪心是无状态的。
```
1 确定dp数组（dp table）以及下标的含义
2 确定递推公式
3 dp数组如何初始化
4 确定遍历顺序
5 举例推导dp数组
```

509. 斐波那契数

70. 爬楼梯

746. **使用最小花费爬楼梯**  


### 第二周
62. **不同路径**  // 二维的

63. 不同路径 II  // 类似 上题

343. **整数拆分**  // 好难

96. **不同的二叉搜索树** // hard 。需要举例，画图，分析，才能找到地推关系。

### 第三周 0 1 背包
```
二维数组

1 二维数组能保证在遍历每一行（物品），的时候，每个物品最多出现一次。所以，不会有物品被重复添加。

2 为什么 for 循环的，可以先 物品，也可先 容量： 举个例子，这两种遍历顺序，都不影响[1] 行的值，以此类推，进而都不会影响后面行的值。

一维数组（滚动！）

先for 物品，再for 容量，dp[j]：max{dp[j], dp[j-w[i]]+v[i]}  {}里的dp[]实际上指的是 上一层的数据（不放物品i）。

第一行手动初始化（像二维数组的第一行一样）。第二行倒序遍历(d[0]初始化为0)。原因是，我要利用的是“上一层”的结果，如果正序遍历，将使用本层前面的dp值，将可能导致物品i

被重复添加！

其实0行也不用手动初始化。如果能能用倒序遍历的方式初始化第一行，就不用单独处理0行了。而且倒序遍历的时候，最后不便利j=0，那么d[j]永远是0。

```

416. **分割等和子集**   // 一开始用了回溯（指数复杂度），结果超时了。用01 背包解决 分割等和子集的问题。

1049. 最后一块石头的重量 II  // 需要建模成 上例。

494. **目标和**  //这道题和前面两道不一样，前面两道是最多能装多少。这道题dp[j]表示 容量为j时，最多有几种装法。dp[0]是变化的。

474. **一和零** // 很好，做出来了。依然是01求子集。只不过物品有 value 有两个维度。 **局部变量**：*数组* 的元素默认有初始值。 而一般元素没有。

```
完全背包

每个物品可以重复使用。 所以*遍历顺序*上，从前到后，不同于01背包。

```

518. **零钱兑换 II**   //求子集，第一思路是排序+回溯，但会超时；但 完全背包方法也可以求子集*个数*。

377. **组合总和 Ⅳ** //上一题是求组合，但不考虑顺序。 如果本题要把所有结果都列出来的话，只能使用回溯算法爆搜。自己举例推导。可以记住这种形式为排列，但别从排列来分析思考。
 
![b站讲解]https://www.bilibili.com/video/BV15q4y1s7wt?spm_id_from=333.337.search-card.all.click&vd_source=8227479b71e61182247876d99eb8d179

70. **爬楼梯**  // 也可以用完全背包的思路来做。

322. **零钱兑换**  // 完全背包

279. **完全平方数**  // 特点 ：完全平方数可以任意使用。

139. **单词拆分** // 完全背包， 131. 分割回文串 只能用回溯。

```
多重背包 问题，就是01背包的拓展。每件物品有若干件。解法就是将多重退化为 01 背包。所有商品都是独立的，即每件物品只有一件。
```

198. **打家劫舍**  // 

213. **打家劫舍 II**   // 取例子作比较了，找到规律了。

337. **打家劫舍 III**   // 树形dp不会。忘记了后序的精髓。 还可以，知道后序之后，一写就直接通过了。

121. **卖股票的最佳时机** // 这道题，暴力会超时(O(n2))。这道题 贪心和dp很像，dp就是需要状态转移。 
```
随想录的方法难想：
1、 玩家一开始获得现金为0   
2、 因为只能买卖一次，所以dp[i] 的意思是，昨天之前都没有卖出过。
dp[i][0]为 -price[i](昨天之前都没获利，今天买入该只股票)，dp[i-1][0]（持有之前的股票）之中选择。 这里dp[i][0] 定义为 最少的金钱花销会不会更好理解。
dp[i][1] 容易理解，不赘述了。
```
122. 买卖股票的最佳时机 II  // 贪心和dp 依然很像。随想录的方法难想。
```
随想录的方法难想：
0、 第i天，*要么手里有股票，要么没有，这两种情况都有自己的递推方式*。
1、 玩家一开始获得现金为0   
2、 因为能买卖多次，所以dp[i] 的意思是，昨天之前都没有卖出过。
dp[i][0]为 昨天卖出了就 dp[i-1][1]-price[i](昨天卖出了，今天买入该只股票)，dp[i-1][0]（持有之前的股票）之中选择。 
dp[i][1] 容易理解，不赘述了。
```

123. **买卖股票的最佳时机 III**  //  难。。但还可以做。

188. **买卖股票的最佳时机 IV**  // 同上

309. **最佳买卖股票时机含冷冻期** // 精确的区分 每一天的状态可能，并根据 昨天的所有状态 推到 今天的每种状态。

714. **买卖股票的最佳时机含手续费**  // 卖出的时候 算上 fee

-------------------------------

300. **最长递增子序列**  // 很爽，自己想出来了。

674. **最长连续递增序列**  // 这道题感觉不需要dp

718. **最长重复子数组**  //  1 个小时做出了o(n2)。 dp[][]

1143. **最长公共子序列**  // 做出来啦

1035. **不相交的线**  // 和上题基本一样。

53. **最大子数组和**  // 贪心也可以做。

------------------
392. 判断子序列  // 这题不需要dp

115. **不同的子序列**  // 难。想不出递推公式。这个只能是  *见多识广*   或者先把**dp矩阵写出来，然后找规律。。**

583. **两个字符串的删除操作** // **dp矩阵写出来，然后找规律。。**

72. **编辑距离** // **dp矩阵写出来，然后找规律。。** 

--------
647. **回文子串**  // 不会。原来要定义**二维**的dp。dp[i][j] 的定义也很重要。









动态规划是 有状态的，贪心是无状态的。
```
1 确定dp数组（dp table）以及下标的含义
2 确定递推公式
3 dp数组如何初始化
4 确定遍历顺序
5 举例推导dp数组
```

509. 斐波那契数

70. 爬楼梯

746. **使用最小花费爬楼梯**  


### 第二周
62. **不同路径**  // 二维的

63. 不同路径 II  // 类似 上题

343. **整数拆分**  // 好难

96. **不同的二叉搜索树** // hard 。需要举例，画图，分析，才能找到地推关系。

### 第三周 0 1 背包
```
二维数组

1 二维数组能保证在遍历每一行（物品），的时候，每个物品最多出现一次。所以，不会有物品被重复添加。

2 为什么 for 循环的，可以先 物品，也可先 容量： 举个例子，这两种遍历顺序，都不影响[1] 行的值，以此类推，进而都不会影响后面行的值。

一维数组（滚动！）

先for 物品，再for 容量，dp[j]：max{dp[j], dp[j-w[i]]+v[i]}  {}里的dp[]实际上指的是 上一层的数据（不放物品i）。

第一行手动初始化（像二维数组的第一行一样）。第二行倒序遍历(d[0]初始化为0)。原因是，我要利用的是“上一层”的结果，如果正序遍历，将使用本层前面的dp值，将可能导致物品i

被重复添加！

其实0行也不用手动初始化。如果能能用倒序遍历的方式初始化第一行，就不用单独处理0行了。而且倒序遍历的时候，最后不便利j=0，那么d[j]永远是0。

```

416. **分割等和子集**   // 一开始用了回溯（指数复杂度），结果超时了。用01 背包解决 分割等和子集的问题。

1049. 最后一块石头的重量 II  // 需要建模成 上例。

494. **目标和**  //这道题和前面两道不一样，前面两道是最多能装多少。这道题dp[j]表示 容量为j时，最多有几种装法。dp[0]是变化的。

474. **一和零** // 很好，做出来了。依然是01求子集。只不过物品有 value 有两个维度。 **局部变量**：*数组* 的元素默认有初始值。 而一般元素没有。

```
完全背包

每个物品可以重复使用。 所以*遍历顺序*上，从前到后，不同于01背包。

```

 //求子集，第一思路是排序+回溯；但 背包方法也可以求子集。

可以抽象为一个n叉树
```
返回值 void backTracking() 
if(end_condiction):
    # 收集结果;
    return;
 
for i in (集合元素) 单层搜索逻辑 (1)
    #得到元素(可能是一list or others) 
    #条件判断               (2)
        #backTracking(,idx)； (3)
        #回溯；撤销处理的节点
```
for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历。
回溯法是一些问题的暴力搜索方法。本质是穷举。


如果是一个集合来求组合的话，就需要startIndex

## 组合   (1) (2) (3) 处出题
77. 组合   这里，每个节点，是一个序列（for循环）。

216.组合总和III   参数 和 结果都不存在重复数字

80. 电话号码的字母组合  限制了每个位置的数字   不是一个集合求组合。不需要index

39. 组合总和   参数不存在重复数字，结果可以存在重复数字。  下一层递归可以包括 当前的位置。 即10行的 idx==i。相比于 *组合总和III* ，我们组要**排序**，来配合剪枝。

41.组合总和II   参数存在重复数字，结果不可以存在重复数字。 去重。牢记：for 循环就是同一层节点。  我们组要**排序**，来配合剪枝和**去重**。

## 分割
131. 分割回文串    应该是一道hard

133. 复原 IP 地址   一些小细节

## 子集问题
78.子集  那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！

90. 子集 II  加上去重。配合**排序**

491. 递增子序列  **不能排序**, 如何**去重**


## 排列   
排列就是 第一个位置固定一个值的时候，变化后面的值（依次取剩余元素）。abc -> acb -> bac -> bca -> cab -> cba
因为每次进入递归都要从头开始找不在temp中的元素。所以处理排列问题就不用使用startIndex了

46.全排列 无重复数字  used   

47.全排列II  直接用**排序 + used** 去重！当然，41.组合总和II  也可以用这样的方法。

41.组合总和II ， 90. 子集 II ，47.全排列II   也可以用set去重，但相对于used数组的版本*效率都要低很多*。一是map的映射时间，而是空间开销变成O(N^2)了

332. 重新安排行程  一般的想法：收集所有满足条件的答案，然后得到最短的。复杂度爆了 O(N!)。  只有直接得到最短的一条路径即可。O(N)左右。
--------------
## 其他
51. N 皇后

37. 解数独  有意思的题目，每个节点都要变量所有的棋盘位置。

![image](https://user-images.githubusercontent.com/67401289/166619625-f11221ce-cb39-4a6c-a829-2af3e45e33c3.png)




可以抽象为一个n叉树
```
返回值 void backTracking() 
if(end_condiction):
    # 收集 *上一轮* 的结果;
    return;
    
... // 这里可以剪去节点

for i in (集合元素) 单层搜索逻辑（该节点孩子数量大小） (1)
    #得到元素e (可能是一list or others) 
    #条件判断               (2)  // 剪枝2，不add(e) , 
        # add(e)       // 伸出枝条
        #backTracking(,idx)； (3)
        #回溯；撤销处理的节点
```
for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历。

回溯法是一些问题的暴力搜索方法。本质是穷举。


如果是一个集合来求组合的话，就需要startIndex

**请把递归树画出来**

## 组合   (1) (2) (3) 处出题

77. **组合**   

216. **组合总和III**    //  参数 和 结果都不存在重复数字。 隐式回溯了 int sum

80. **电话号码的字母组合**    // 把树画出来。


39. **组合总和**   // 参数不存在重复数字（*所以不需要去重*），结果可以不可以 存在重复组合。  下一层递归可以包括 当前的位置。 即10行的 idx==i。相比于 *组合总和III* ，我们组要**排序**，来配合剪枝。
```
candidates = [3,2,6,7], target = 7
```

41.**组合总和II**

// 参数存在重复数字（*所以需要去重*），结果不可以 存在重复组合。   我们组要**排序**，来配合剪枝和**去重**。 

//是hash 题目中，15. **三数之和** ，  **四数之和** 的拓展版(排序+二分查找)，不限制组合的长度。
```
candidates = [10,1,2,7,6,1,5], target = 8,
```


## 分割
131. **分割回文串**   // 仔细分析，应该用回溯的解法。把树画出来，确定节点，如何遍历节点里的元素。

133. **复原 IP 地址**  //  仔细分析，应该用回溯的解法。  好题，许多细节。

## 子集问题
78.**子集**   // 如果组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的 *所有节点* ！

90. **子集 II**  // 这里的去重和41.**组合总和II**  。同样，利用**排序**。 如果要是*全排列*的话，每次要从0开始遍历，为了跳过已入栈的元素，需要使用*used*。

491. **递增子序列**  //  没法儿排序，本层还要去重！！ **非常难**。用 *set* 去重。
```
# 因为不能排序，所以不能
if(end>start){
                if(nums[end]==nums[end-1]) // 同一节点，相同元素，只取一个。
                    continue;                                
            }
用set 来去重比较合适。
```


## 排列   
*得用used 来遍历去重*

46.**全排列** // 无重复数字  因为每次进入递归都要**从头开始找**, 每一层的节点大小都一样。用 *used* 代替 *startIndex*。

47.**全排列II**  //  直接用**排序 + used** 去重！

332. 重新安排行程  一般的想法：收集所有满足条件的答案，然后得到最短的。复杂度爆了 O(N!)。  只有直接得到最短的一条路径即可。O(N)左右。
--------------
## 其他
51. N 皇后

37. 解数独  有意思的题目，每个节点都要变量所有的棋盘位置。

![image](https://user-images.githubusercontent.com/67401289/166619625-f11221ce-cb39-4a6c-a829-2af3e45e33c3.png)



